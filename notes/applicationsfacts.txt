
Stack
    - OS: Keep track of method calls in program (Activation Records)
    - Compilers: Converstion of arithmetic expression to machine code

Queue
    - OS: Print queue, process scheduling, input buffer
    - Modeling and simulating of computer and phone networks, road systems
    - Jai Alai

Binary Trees:
    - Encryption, databases, expert systems

B-Tree
    - Designed to work on magnetic disks and secondary storage devices
    - Minimize disk IO operations 



void insert(int item) {
    BTNode newNode = new BTNode(item);
    BTNode cursor = root;
    boolean done = false;
    if(root == null) {
        root = newNode;
    } else {
        while(!done) {
            if(item < cursor.getData()) {
                if(cursor.getLeft() == null) {
                    cursor.setLeft(newNode);
                    done = true;
                } else {
                    cursor = cursor.getLeft();
                }
            } else if(item > cursor.getData()) {
                if(cursor.getRigth() == null) {
                    cursor.setRight(newNode);
                    done = true;
                } else {
                    cursor = cursor.getRight();
                }
            } else {
                done = true;
            }
        }
    }
}

best case: O(logN)
worst case: O(N)

boolean remove(int item) {
    BTNode parent = null;
    BTNode cursor = root;
    while(cursor != null && cursor.getData() != item) {
        parent = cursor;
        if(item < cursor.getData()) {
            cursor = cursor.getLeft();
        } else {
            cursor = cursor.getRight();
        }
    }
    if(cursor == null) {
        return false;
    } else {
        if(cursor == root && cursor.getLeft() == null) {
            cursor = cursor.getRight();
        } else if(cursor != root && cursor.getLeft() == null) {
            if(cursor == parent.getLeft()) {
                parent.setLeft(cursor.getRight());
            } else {
                parent.setRight(cursor.getRight());
            }
        } else {
            cursor.setData(cursor.getLeft().getRightMostData());
            cursor.setLeft(cursor.getLeft().removeRightMost());
        }
        return true;
    }
}

int getRightMostData() {
    if(right == null) {
        return data;
    } else {
        return right.getRightMostData();
    }
}

BTNode removeRightMost() {
    if(right == null) {
        return left;
    } else {
        right = right.removeRightMost();
        return this;
    }
}

Heap is a binary tree such that for every node in the tree,
 that node will have greater value than both of its children



 Storage
 array

 for a node at index i:
 parent at (i - 1) / 2
 child1 at 2i + 1
 child2 at 2i + 2

 void insert(int item) {
    int pos;
    heapSize++;
    if(heapSize == maxSize) {
        // throw exception
    }
    pos = heapSize - 1;
    while(pos > 0) {
        int parent = (pos - 1) / 2
        if(arr[parent] < arr[pos]) {
            swap(parent, pos)
        }
    }
 }

 int remove() {
    if(heapSize == 0) {
        // throw exception
    }
    int result = arr[0];
    arr[0] = arr[heapSize - 1];
    heapSize--;
    fixHeap();
    return result;
 }

 void fixHeap() {
    int pos = 0;
    int child;
    while(2 * pos + 1 < heapSize) {
        child = pos * 2 + 1;
        if(child < heapSize - 1 && arr[child + 1] > arr[child]) {
            child++;
        }
        if(arr[pos] >= arr[child]) {
            return;
        }
        swap(pos, child);
        pos = child;
    }
 }